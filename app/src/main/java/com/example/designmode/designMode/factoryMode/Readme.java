package com.example.designmode.designMode.factoryMode;

//工厂模式，每一个都是基于上一个工厂模式所修改


/**
 * 简单工厂模式：
 * 定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口
 * 这种工厂模式有且仅有一个工厂，很不灵活，每次需要加新物品，都需要往工厂内添加。
 * 缺点：增加新的材质的品类，就要大改代码，工厂只有一个
 *
 */

/**
 * 简单工厂：
 * （1）定义一个杯子接口，里面的方法为useCup()
 * （2）定义几个杯子的类，实现Cup()接口，实现Cuo()接口中的方法
 * （3）定义一个杯子工厂的类，定义一个productCup()方法，通过传入的不同的参数返回不同Cup
 * （4）完成简单工厂模式的建造
 */

/**
 * 工厂方法模式：
 * 多个工厂，实现了同一个工厂接口，生产的东西都是一样的
 *
 * 定义一个用于创建对象的接口，让子类决定哪一个类实例化。
 * 工厂方法模式让一个类的实例化延迟到其子类
 * 缺点：有多个工厂，但是不能增加其他类型的工厂
 */

/**
 * 工厂方法模式:
 * (1) 定义一个工厂接口，接口内的方法返回杯子Cup()类
 * (2) 定义一个陶瓷杯工厂，实现了工厂接口，返回的Cup类为 陶瓷杯子
 * (3) 定义一个玻璃杯工厂，实现了工厂接口，返回的Cup类为 玻璃杯子
 * (4) 完成工厂方法模式的建造
 */

/**
 * 抽象工厂模式：
 * 提供一个创建一系列相关或者依赖对象的接口，而无需指定他们具体的类
 * 缺点：一个工厂接口可接入多个工厂，对原产品族增加或减少东西，代码需要大改，因为要改接口
 * 优点：增加新的品类的物品很方便
 */

/**
 * 抽象工厂模式：
 * (1) 定义多个生产的物品的接口，如Cup()，Cover()
 * (2) 定义一个工厂，返回要生产的类型,这里有两个，所以有两个方法，分别返回cup()和cover()
 * (3) 在每种杯子里面都增加盖子，（改动较多）
 * (4) 完成抽象工厂模式的建造
 */
